kendall_array[, as.character(rho)] <- kendall
}
assign(paste0("taus_t4_iid", rhos_fileendings[j]), colMeans(kendall_array))
save(list = paste0("taus_t4_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_taus/", paste0(paste0("taus_t4_iid", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
## "Multivariate t1" DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(-0.985, -0.52, 0, 0.52, 0.985)
rhos_list <- list(rhos_PowerGraph, rhos_CIs, rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
kendall_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, as.character(rhos))) # Initialize results array
for (rho in rhos) {
kendall <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_Mvt_iid(Ti, rho, i, 1)
RCor::RCor(XY[,1], XY[,2], method = "tau", Inference = FALSE)[[1]]
}
kendall_array[, as.character(rho)] <- kendall
}
assign(paste0("taus_t1_iid", rhos_fileendings[j]), colMeans(kendall_array))
save(list = paste0("taus_t1_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_taus/", paste0(paste0("taus_t1_iid", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
## Normal Exponential DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(-0.95, -0.59, 0, 0.59, 0.95)
rhos_list <- list(rhos_PowerGraph, rhos_CIs, rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
kendall_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, as.character(rhos))) # Initialize results array
for (rho in rhos) {
kendall <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_NormExp_iid(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "tau", Inference = FALSE)[[1]]
}
kendall_array[, as.character(rho)] <- kendall
}
assign(paste0("taus_NExp_iid", rhos_fileendings[j]), colMeans(kendall_array))
save(list = paste0("taus_NExp_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_taus/", paste0(paste0("taus_NExp_iid", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
## "Multivariate Poisson" DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(0, 0.34, 0.69)
rhos_list <- list(rhos_PowerGraph, rhos_CIs, rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
kendall_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
for (rho in rhos) {
kendall <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvPois_iid(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "gamma", Inference = FALSE)[[1]]
}
kendall_array[, as.character(rho)] <- kendall
}
assign(paste0("gammas_MvPois_iid", rhos_fileendings[j]), colMeans(kendall_array))
save(list = paste0("gammas_MvPois_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_taus/", paste0(paste0("taus_MvPois_iid", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
set.seed(i)
i <- 1
rho
set.seed(i)
X <- rpois(Ti, lambda = 1)
Y <- rep(NA, Ti)
for (t in 1:Ti) {
Y[t] <- rbinom(1, X[t], rho) + rbinom(1, rpois(1, lambda = 1), 1 - rho)
}
X
Y
t <- 1
rbinom(1, X[t], rho)
## "Multivariate Poisson" DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(0, 0.34, 0.69)
rhos_list <- list(rhos_PowerGraph[100:199], rhos_CIs[91:181], rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
kendall_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
for (rho in rhos) {
kendall <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvPois_iid(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "gamma", Inference = FALSE)[[1]]
}
kendall_array[, as.character(rho)] <- kendall
}
assign(paste0("gammas_MvPois_iid", rhos_fileendings[j]), colMeans(kendall_array))
save(list = paste0("gammas_MvPois_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_taus/", paste0(paste0("taus_MvPois_iid", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
## "Multivariate Zipf" DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(0, 0.174, 0.677)
rhos_list <- list(rhos_PowerGraph[100:199], rhos_CIs[91:181], rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
kendall_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, as.character(rhos))) # Initialize results array
for (rho in rhos) {
kendall <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvZipf_iid(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "gamma", Inference = FALSE)[[1]]
}
kendall_array[, as.character(rho)] <- kendall
}
assign(paste0("gammas_MvZipf_iid", rhos_fileendings[j]), colMeans(kendall_array))
save(list = paste0("gammas_MvZipf_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_taus/", paste0(paste0("taus_MvZipf_iid", rhos_fileendings[j]), ".RData"))))
}
source("~/Documents/Dr.Wermuth/Projects/RankAutocorrelations/replication_RCor/code/True_Taus.R", echo=TRUE)
source("~/Documents/Dr.Wermuth/Projects/RankAutocorrelations/replication_RCor/code/True_Rhos.R", echo=TRUE)
## "Multivariate Poisson" DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(0, 0.34, 0.69)
rhos_list <- list(rhos_PowerGraph[100:199], rhos_CIs[91:181], rhos_CIs_short)
j <- 1
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
i
i <- 1
XY <- Gen_MvPois_iid(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "rhob", Inference = FALSE)[[1]]
XY
RCor
## "Multivariate Poisson" DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(0, 0.34, 0.69)
rhos_list <- list(rhos_PowerGraph[100:199], rhos_CIs[91:181], rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvPois_iid(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "rho_b", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhobs_MvPois_iid", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhobs_MvPois_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhobs_MvPois_iid", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
## "Multivariate Zipf" DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(0, 0.174, 0.677)
rhos_list <- list(rhos_PowerGraph[100:199], rhos_CIs[91:181], rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, as.character(rhos))) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvZipf_iid(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "rho_b", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhobs_MvZipf_iid", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhobs_MvZipf_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhobs_MvZipf_iid", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
## "Multivariate Skellam" DGP (iid) -------------------------------------------------
rhos_CIs_short <- c(-0.665, -0.345, 0, 0.345, 0.665)
rhos_list <- list(rhos_PowerGraph, rhos_CIs, rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvSkellam_iid(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "rho_b", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhobs_MvSkellam_iid", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhobs_MvSkellam_iid", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhobs_MvSkellam_iid", rhos_fileendings[j]), ".RData"))))
}
## "Multivariate Normal" DGP (Time Series) -------------------------------------------------
rhos_CIs_short <- c(-0.95, -0.59, 0, 0.59, 0.95)
rhos_list <- list(rhos_PowerGraph, rhos_CIs, rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, as.character(rhos))) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_Mvt_TS(Ti, rho, i, Inf)
RCor::RCor(XY[,1], XY[,2], method = "rho", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhos_norm_TS", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhos_norm_TS", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhos_norm_TS", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
# "Multivariate t(4)" DGP (Time Series) -------------------------------------------------
rhos_CIs_short <- c(-0.96, -0.58, 0, 0.58, 0.96)
rhos_list <- list(rhos_PowerGraph, rhos_CIs, rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, as.character(rhos))) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_Mvt_TS(Ti, rho, i, 4)
RCor::RCor(XY[,1], XY[,2], method = "rho", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhos_t4_TS", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhos_t4_TS", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhos_t4_TS", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
# "Multivariate t(1)" DGP (Time Series) -------------------------------------------------
rhos_CIs_short <- c(-0.985, -0.51, 0, 0.51, 0.985)
rhos_list <- list(rhos_PowerGraph, rhos_CIs, rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, as.character(rhos))) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_Mvt_TS(Ti, rho, i, 1)
RCor::RCor(XY[,1], XY[,2], method = "rho", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhos_t1_TS", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhos_t1_TS", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhos_t1_TS", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
# "Multivariate TEAR(1)" DGP (Time Series) -------------------------------------------------
rhos_CIs_short <- c(0, 0.48, 0.845)
rhos_list <- list(rhos_PowerGraph[100:199], rhos_CIs[91:181], rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_TEAR_TS(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "rho", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhos_TEAR_TS", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhos_TEAR_TS", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhos_TEAR_TS", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
# "Multivariate Poisson" DGP (Time Series) -------------------------------------------------
rhos_CIs_short <- c(0, 0.34, 0.69)
rhos_list <- list(rhos_PowerGraph[100:199], rhos_CIs[91:181], rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvPois_TS(Ti, rho, i)
RCor::RCor(XY[,1], XY[,2], method = "rho_b", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhobs_MvPois_TS", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhobs_MvPois_TS", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhobs_MvPois_TS", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
# "Multivariate Zipf" DGP (Time Series) -------------------------------------------------
rhos_CIs_short <- c(0, 0.46, 0.865)
rhos_list <- list(rhos_PowerGraph[100:199], rhos_CIs[91:181], rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvZipf_TS(Ti, rho, i, 1000)
RCor::RCor(XY[,1], XY[,2], method = "rho_b", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhobs_MvZipf_TS", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhobs_MvZipf_TS", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhobs_MvZipf_TS", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
# "Multivariate Skellam" DGP (Time Series) -------------------------------------------------
rhos_CIs_short <- c(-0.65, -0.33, 0, 0.33, 0.65)
rhos_list <- list(rhos_PowerGraph, rhos_CIs, rhos_CIs_short)
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
for (j in seq_along(rhos_list)){
rhos <- rhos_list[[j]]
spearman_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array
for (rho in rhos) {
spearman <- foreach(i = 1:MC, .combine = 'c') %dopar% {
XY <- Gen_MvSkellam_TS(Ti, rho, i, 1000)
RCor::RCor(XY[,1], XY[,2], method = "rho_b", Inference = FALSE)[[1]]
}
spearman_array[, as.character(rho)] <- spearman
}
assign(paste0("rhobs_MvSkellam_TS", rhos_fileendings[j]), colMeans(spearman_array))
save(list = paste0("rhobs_MvSkellam_TS", rhos_fileendings[j]), file = here(paste0("results/simulations/true_rhos/", paste0(paste0("rhobs_MvSkellam_TS", rhos_fileendings[j]), ".RData"))))
}
stopCluster(cl)
library(mnorm)
library(DescTools)
library(data.table)
library(tsDyn)
library(doParallel)
library(doRNG)
library(foreach)
library(here)
# install_github("jan-lukas-wermuth/RCor")
library(RCor)
source(file = here("code/functions/LRV_estim.R")) # Source Long-Run Variance estimation function
invisible(lapply(list.files(here("results/simulations/true_taus"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
invisible(lapply(list.files(here("results/simulations/true_rhos"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
# ============================================================
# Title:      Coverage Simulations for Confidence Intervals
# Author:     Jan-Lukas Wermuth
# Date:       2025-05-09
# Purpose:    This script simulates the empirical coverage rates
#             for all the DGPs considered in the paper.
# ============================================================
rm(list = ls())
library(mnorm)
library(DescTools)
library(data.table)
library(tsDyn)
library(doParallel)
library(doRNG)
library(foreach)
library(here)
# install_github("jan-lukas-wermuth/RCor")
library(RCor)
source(file = here("code/functions/LRV_estim.R")) # Source Long-Run Variance estimation function
invisible(lapply(list.files(here("results/simulations/true_taus"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
invisible(lapply(list.files(here("results/simulations/true_rhos"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
?RCor
# library(devtools)
install_github("jan-lukas-wermuth/RCor")
library(devtools)
install_github("jan-lukas-wermuth/RCor")
install_github("jan-lukas-wermuth/RCor", force = TRUE)
?RCor
?RCor
# library(devtools)
# install_github("jan-lukas-wermuth/RCor")
library(RCor)
?RCor
help("RCor", package = "RCor")
library(pkgload)
?RCor
install_github("jan-lukas-wermuth/RCor")
install_github("jan-lukas-wermuth/RCor", force = TRUE)
library(RCor)
?RCor
install.packages("pkgload")
install.packages("pkgload")
library(mnorm)
library(DescTools)
library(data.table)
library(tsDyn)
library(doParallel)
library(doRNG)
library(foreach)
library(here)
library(devtools)
# install_github("jan-lukas-wermuth/RCor")
library(RCor)
?RCor
install_github("jan-lukas-wermuth/RCor")
install_github("jan-lukas-wermuth/RCor", ref = "main")
install_github("jan-lukas-wermuth/RCor", ref = "main", quiet = FALSE)
install_github("jan-lukas-wermuth/RCor", ref = "main", quiet = FALSE, force = TRUE)
RCor
?RCor
library(RCor)
library(devtools)
install_github("jan-lukas-wermuth/RCor", ref = "main", quiet = FALSE, force = TRUE)
library(RCor)
?RCor
?RCor
library(roxygen2)
library(devtools)
install_github("jan-lukas-wermuth/RCor", ref = "main", quiet = FALSE, force = TRUE)
library(RCor)
?RCor
RCor
# ============================================================
# Title:      Coverage Simulations for Confidence Intervals
# Author:     Jan-Lukas Wermuth
# Date:       2025-05-09
# Purpose:    This script simulates the empirical coverage rates
#             for all the DGPs considered in the paper.
# ============================================================
rm(list = ls())
library(mnorm)
library(DescTools)
library(data.table)
library(tsDyn)
library(doParallel)
library(doRNG)
library(foreach)
library(here)
# library(devtools)
# install_github("jan-lukas-wermuth/RCor")
library(RCor)
source(file = here("code/functions/LRV_estim.R")) # Source Long-Run Variance estimation function
invisible(lapply(list.files(here("results/simulations/true_taus"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
invisible(lapply(list.files(here("results/simulations/true_rhos"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
# Parameter Speicification ------------------------------------------------
MC <- 1000
alpha <- 0.1
SampleSizes <- c(50, 200, 800)
# Title:      Coverage Simulations for Confidence Intervals
# Author:     Jan-Lukas Wermuth
# Date:       2025-05-09
# Purpose:    This script simulates the empirical coverage rates
#             for all the DGPs considered in the paper.
rm(list = ls())
library(mnorm)
library(DescTools)
library(data.table)
library(tsDyn)
library(doParallel)
library(doRNG)
library(foreach)
library(here)
# library(devtools)
# install_github("jan-lukas-wermuth/RCor")
library(RCor)
source(file = here("code/functions/LRV_estim.R")) # Source Long-Run Variance estimation function
invisible(lapply(list.files(here("results/simulations/true_taus"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
invisible(lapply(list.files(here("results/simulations/true_rhos"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
# Parameter Speicification ------------------------------------------------
MC <- 1000
SampleSizes <- c(50, 200, 800)
# Continuous IID Processes ------------------------------------------------
## Multivariate normal DGP ------------------------------------------------
alphas_CIs_short <- c(-0.95, -0.59, 0, 0.59, 0.95)
decision_kendall_array_norm <- array(data = NA, dim = c(length(SampleSizes), MC, length(alphas_CIs_short)), dimnames = list(SampleSizes, 1:MC, alphas_CIs_short)) # Initialize results array
alpha <- -0.95
Ti <- 50
i <- 1
set.seed(i) # Is it sensible to use the same seed for all sizes? I think yes
XY <- Gen_MvN_iid(Ti, alpha, i)
# Title:      Coverage Simulations for Confidence Intervals
# Author:     Jan-Lukas Wermuth
# Date:       2025-05-09
# Purpose:    This script simulates the empirical coverage rates
#             for all the DGPs considered in the paper.
rm(list = ls())
library(mnorm)
library(DescTools)
library(data.table)
library(tsDyn)
library(doParallel)
library(doRNG)
library(foreach)
library(here)
# library(devtools)
# install_github("jan-lukas-wermuth/RCor")
library(RCor)
invisible(lapply(list.files(here("code/functions"), pattern = "\\.R$", full.names = TRUE), source)) # Load all the functions
invisible(lapply(list.files(here("results/simulations/true_taus"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
invisible(lapply(list.files(here("results/simulations/true_rhos"), pattern = "\\.RData$", full.names = TRUE), function(x) load(x, envir = globalenv())))
# Parameter Speicification ------------------------------------------------
MC <- 1000
SampleSizes <- c(50, 200, 800)
# Continuous IID Processes ------------------------------------------------
## Multivariate normal DGP ------------------------------------------------
alphas_CIs_short <- c(-0.95, -0.59, 0, 0.59, 0.95)
decision_kendall_array_norm <- array(data = NA, dim = c(length(SampleSizes), MC, length(alphas_CIs_short)), dimnames = list(SampleSizes, 1:MC, alphas_CIs_short)) # Initialize results array
alpha <- -0.95
Ti <- 50
i <- 1
set.seed(i) # Is it sensible to use the same seed for all sizes? I think yes
XY <- Gen_MvN_iid(Ti, alpha, i)
kendall <- RCor(XY[,1], XY[,2], method = "tau", IID = TRUE, Fisher = FALSE, Inference = TRUE)
kendall
kendall[2]
kendall[[2]]
kendall[[3]]
here("results/simulations/coverages")
here("results/simulations/coverages/tau_cov_norm_iid.RData")
2/pi*asin(0.95)
taus_t4_iid_CIs_short
taus_t1_iid_CIs_short
here()
# Title:      Coverage Simulations for Confidence Intervals
# Author:     Jan-Lukas Wermuth
# Date:       2025-05-09
# Purpose:    This script simulates the empirical coverage rates
#             for all the DGPs considered in the paper.
rm(list = ls())
library(mnorm)
library(DescTools)
library(data.table)
library(tsDyn)
