library(mnorm)
library(mvtnorm)
library(DescTools)
library(data.table)
library(tsDyn)
library(doParallel)
library(doRNG)

source(file = "/home/fuchs/agmisc/wermuth/Marc/LRV_estim.R") # Source Long-Run Variance estimation function

################################## Rank autocorrelations: Simulations ##################################

# Specify general variables that are needed in all steps
MC <- 1000
alphas <- c(0.1, 0.05, 0.01)
SampleSizes <- c(50, 200, 800)
# rhos <- round(head(seq(-1, 1, 0.01), -1)[-1], digits = 2) # get rid of the first (-1) and last (1) element of the rho-vector
rhos <- c(-0.16, -0.08, 0, 0.08, 0.16)
#### Step 1: IID processes (independence between processes (H0) and across elements within each process) -- Corollary 2
## Bivariate normal distribution
decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        XY <- mnorm::rmnorm(Ti, mean = rep(0, d), sigma = matrix(c(1, rho, rho, 1), ncol=2))
        X <- XY[,1]
        Y <- XY[,2]
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*2/3/sqrt(Ti), qnorm(1 - alpha/2)*2/3/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        XY <- mnorm::rmnorm(Ti, mean = rep(0, d), sigma = matrix(c(1, rho, rho, 1), ncol=2))
        X <- XY[,1]
        Y <- XY[,2]
        pearson <- cor(X, Y)
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        XY <- mnorm::rmnorm(Ti, mean = rep(0, d), sigma = matrix(c(1, rho, rho, 1), ncol=2))
        X <- XY[,1]
        Y <- XY[,2]
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

save(decision_kendall_array, file = "/home/fuchs/agmisc/wermuth/Marc/Kendall_BivNorm.RData")
save(decision_pearson_array, file = "/home/fuchs/agmisc/wermuth/Marc/Pearson_BivNorm.RData")
save(decision_spearman_array, file = "/home/fuchs/agmisc/wermuth/Marc/Spearman_BivNorm.RData")


## Bivariate t-distribution with 4 degrees of freedom
rhos <- c(-0.14, -0.07, 0, 0.07, 0.14)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rt(Ti, df = 4)
        Y <- rho * X + sqrt(1 - rho^2) * rt(Ti, df = 4)
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*2/3/sqrt(Ti), qnorm(1 - alpha/2)*2/3/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rt(Ti, df = 4)
        Y <- rho * X + sqrt(1 - rho^2) * rt(Ti, df = 4)
        pearson <- cor(X, Y)
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti)))) # The asymptotic distribution of Pearson corr is (under independence) identical to the normal case (see Hassler OSTA-book p. 205 and Serfling, 1980, p.125/126)
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rt(Ti, df = 4)
        Y <- rho * X + sqrt(1 - rho^2) * rt(Ti, df = 4)
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti)))) # The asymptotic distribution of Pearson corr is (under independence) identical to the normal case (see Hassler OSTA-book p. 205 and Serfling, 1980, p.125/126)
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

save(decision_kendall_array, file = "/home/fuchs/agmisc/wermuth/Marc/Kendall_t4.RData")
save(decision_pearson_array, file = "/home/fuchs/agmisc/wermuth/Marc/Pearson_t4.RData")
save(decision_spearman_array, file = "/home/fuchs/agmisc/wermuth/Marc/Spearman_t4.RData")


## Bivariate Cauchy distribution
rhos <- c(-0.07, -0.03, 0, 0.03, 0.07)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rt(Ti, df = 1)
        Y <- rho * X + sqrt(1 - rho^2) * rt(Ti, df = 1)
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*2/3/sqrt(Ti), qnorm(1 - alpha/2)*2/3/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rt(Ti, df = 1)
        Y <- rho * X + sqrt(1 - rho^2) * rt(Ti, df = 1)
        pearson <- cor(X, Y)
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rt(Ti, df = 1)
        Y <- rho * X + sqrt(1 - rho^2) * rt(Ti, df = 1)
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

save(decision_kendall_array, file = "/home/fuchs/agmisc/wermuth/Marc/Kendall_Cauchy.RData")
save(decision_pearson_array, file = "/home/fuchs/agmisc/wermuth/Marc/Pearson_Cauchy.RData")
save(decision_spearman_array, file = "/home/fuchs/agmisc/wermuth/Marc/Spearman_Cauchy.RData")

## Bivariate normal/exponential distribution
rhos <- c(-0.16, -0.08, 0, 0.08, 0.16)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rnorm(Ti)
        Y <- qexp(pnorm(rho * X + sqrt(1 - rho^2) * rnorm(Ti)))
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*2/3/sqrt(Ti), qnorm(1 - alpha/2)*2/3/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rnorm(Ti)
        Y <- qexp(pnorm(rho * X + sqrt(1 - rho^2) * rnorm(Ti)))
        pearson <- cor(X, Y)
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rnorm(Ti)
        Y <- qexp(pnorm(rho * X + sqrt(1 - rho^2) * rnorm(Ti)))
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)


## Discrete Distribution: Pois
mu <- 1 # Specify 0.5 in order to get the DGP with the higher tie probability
# rhos <- round(head(seq(0, 1, 0.01), -1), digits = 2) # negative dependence is difficult for count data
rhos <- c(0, 0.04, 0.09)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_tau_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_gamma_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_rho_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = mu)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, rpois(1, lambda = mu), 1 - rho)
        }
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti))))
      }
      decision_tau_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = mu)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, rpois(1, lambda = mu), 1 - rho)
        }
        X_TieProb <- sum((table(X)/length(X))^2)
        Y_TieProb <- sum((table(Y)/length(Y))^2)
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        tau_b <- cor(X, Y, method = "kendall")
        as.numeric(isFALSE(data.table::between(tau_b, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb) / (1 - Y_TieProb))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb) / (1 - Y_TieProb))/sqrt(Ti))))
      }
      decision_gamma <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = mu)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, rpois(1, lambda = mu), 1 - rho)
        }
        X_TieProb <- sum((table(X)/length(X))^2)
        Y_TieProb <- sum((table(Y)/length(Y))^2)
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        kendall_info <- DescTools:::.DoCount(X, Y)
        gamma <- (kendall_info$C - kendall_info$D) / (kendall_info$C + kendall_info$D)
        as.numeric(isFALSE(data.table::between(gamma, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = mu)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, rpois(1, lambda = mu), 1 - rho)
        }
        pearson <- cor(X, Y)
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = mu)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, rpois(1, lambda = mu), 1 - rho)
        }
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sqrt((1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt((1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti))))
      }
      decision_rho_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = mu)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, rpois(1, lambda = mu), 1 - rho)
        }
        rho_b <- cor(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(rho_b, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_tau_b_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_tau_b
      decision_gamma_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_gamma
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
      decision_rho_b_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_rho_b
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

## Discrete Distribution: Zipf
mu <- 1 # Specify 0.5 in order to get the DGP with the higher tie probability
rhos <- round(head(seq(0, 1, 0.01), -1), digits = 2) # negative dependence is difficult for count data
# rhos <- c(0, 0.008, 0.019)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_tau_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_gamma_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_rho_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  print("A")
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- VGAM::rzeta(Ti, shape = mu) - 1
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, VGAM::rzeta(1, shape = mu) - 1, 1 - rho)
        }
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti))))
      }
      # decision_tau_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   X <- VGAM::rzeta(Ti, shape = mu) - 1
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, VGAM::rzeta(1, shape = mu) - 1, 1 - rho)
      #   }
      #   X_TieProb <- sum((table(X)/length(X))^2)
      #   Y_TieProb <- sum((table(Y)/length(Y))^2)
      #   X_TieProb3 <- sum((table(X)/length(X))^3)
      #   Y_TieProb3 <- sum((table(Y)/length(Y))^3)
      #   tau_b <- cor(X, Y, method = "kendall")
      #   as.numeric(isFALSE(data.table::between(tau_b, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb) / (1 - Y_TieProb))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb) / (1 - Y_TieProb))/sqrt(Ti))))
      # }
      # decision_gamma <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   X <- VGAM::rzeta(Ti, shape = mu) - 1
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, VGAM::rzeta(1, shape = mu) - 1, 1 - rho)
      #   }
      #   X_TieProb <- sum((table(X)/length(X))^2)
      #   Y_TieProb <- sum((table(Y)/length(Y))^2)
      #   X_TieProb3 <- sum((table(X)/length(X))^3)
      #   Y_TieProb3 <- sum((table(Y)/length(Y))^3)
      #   kendall_info <- DescTools:::.DoCount(X, Y)
      #   gamma <- (kendall_info$C - kendall_info$D) / (kendall_info$C + kendall_info$D)
      #   as.numeric(isFALSE(data.table::between(gamma, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)/sqrt(Ti))))
      # }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- VGAM::rzeta(Ti, shape = mu) - 1
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, VGAM::rzeta(1, shape = mu) - 1, 1 - rho)
        }
        pearson <- cor(X, Y)
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- VGAM::rzeta(Ti, shape = mu) - 1
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, VGAM::rzeta(1, shape = mu) - 1, 1 - rho)
        }
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sqrt((1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt((1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti))))
      }
      # decision_rho_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   X <- VGAM::rzeta(Ti, shape = mu) - 1
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, VGAM::rzeta(1, shape = mu) - 1, 1 - rho)
      #   }
      #   rho_b <- cor(X, Y, method = "spearman")
      #   as.numeric(isFALSE(data.table::between(rho_b, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      # }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      #decision_tau_b_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_tau_b
      #decision_gamma_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_gamma
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
      #decision_rho_b_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_rho_b
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

save(decision_kendall_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/Kendall_zipf.RData")
save(decision_spearman_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/Spearman_zipf.RData")
save(decision_pearson_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/Pearson_zipf.RData")



## Discrete Distribution: Skellam
# rhos <- round(head(seq(0, 1, 0.01), -1), digits = 2) # negative dependence is difficult for count data
rhos <- c(-0.11, -0.055, 0, 0.055, 0.11)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_tau_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_gamma_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_rho_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = 1) - rpois(Ti, lambda = 1)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          u <- rpois(1, lambda = 1) - rpois(1, lambda = 1)
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(u) * rbinom(1, abs(u), abs(1 - abs(rho)))
        }
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti))))
      }
      decision_tau_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = 1) - rpois(Ti, lambda = 1)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          u <- rpois(1, lambda = 1) - rpois(1, lambda = 1)
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(u) * rbinom(1, abs(u), abs(1 - abs(rho)))
        }
        X_TieProb <- sum((table(X)/length(X))^2)
        Y_TieProb <- sum((table(Y)/length(Y))^2)
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        tau_b <- cor(X, Y, method = "kendall")
        as.numeric(isFALSE(data.table::between(tau_b, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb) / (1 - Y_TieProb))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb) / (1 - Y_TieProb))/sqrt(Ti))))
      }
      decision_gamma <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = 1) - rpois(Ti, lambda = 1)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          u <- rpois(1, lambda = 1) - rpois(1, lambda = 1)
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(u) * rbinom(1, abs(u), abs(1 - abs(rho)))
        }
        X_TieProb <- sum((table(X)/length(X))^2)
        Y_TieProb <- sum((table(Y)/length(Y))^2)
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        kendall_info <- DescTools:::.DoCount(X, Y)
        gamma <- (kendall_info$C - kendall_info$D) / (kendall_info$C + kendall_info$D)
        as.numeric(isFALSE(data.table::between(gamma, qnorm(alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)/sqrt(Ti), qnorm(1 - alpha/2)*sqrt(4/9 * (1 - X_TieProb3) * (1 - Y_TieProb3) / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = 1) - rpois(Ti, lambda = 1)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          u <- rpois(1, lambda = 1) - rpois(1, lambda = 1)
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(u) * rbinom(1, abs(u), abs(1 - abs(rho)))
        }
        pearson <- cor(X, Y)
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = 1) - rpois(Ti, lambda = 1)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          u <- rpois(1, lambda = 1) - rpois(1, lambda = 1)
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(u) * rbinom(1, abs(u), abs(1 - abs(rho)))
        }
        X_TieProb3 <- sum((table(X)/length(X))^3)
        Y_TieProb3 <- sum((table(Y)/length(Y))^3)
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sqrt((1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti), qnorm(1 - alpha/2)*sqrt((1 - X_TieProb3) * (1 - Y_TieProb3))/sqrt(Ti))))
      }
      decision_rho_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        X <- rpois(Ti, lambda = 1) - rpois(Ti, lambda = 1)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          u <- rpois(1, lambda = 1) - rpois(1, lambda = 1)
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(u) * rbinom(1, abs(u), abs(1 - abs(rho)))
        }
        rho_b <- cor(X, Y, method = "spearman")
        as.numeric(isFALSE(data.table::between(rho_b, qnorm(alpha/2)/sqrt(Ti), qnorm(1 - alpha/2)/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_tau_b_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_tau_b
      decision_gamma_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_gamma
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
      decision_rho_b_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_rho_b
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)



#### Step 2: Stationary, ergodic and absolutely regular processes (independence between processes (H0) but dependence within each process) -- Corollary 1
# Specify general variables that are needed in all steps
## normal process
# rhos <- round(head(seq(-1, 1, 0.01), -1)[-1], digits = 2) # negative dependence is difficult for count data
rhos <- c(-0.16, -0.08, 0, 0.08, 0.16)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) # Is it sensible to use the same seed for all sizes? I think yes
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = rnorm)
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = rnorm)
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) # Is it sensible to use the same seed for all sizes? I think yes
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = rnorm)
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = rnorm)
        pearson <- cor(X, Y)
        sigma <- sqrt(Rho_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) # Is it sensible to use the same seed for all sizes? I think yes
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = rnorm)
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = rnorm)
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        sigma <- 3/2 * sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

save(decision_kendall_array, file = "/home/fuchs/agmisc/wermuth/Marc/Kendall_TS_norm.RData")
save(decision_pearson_array, file = "/home/fuchs/agmisc/wermuth/Marc/Pearson_TS_norm.RData")
save(decision_spearman_array, file = "/home/fuchs/agmisc/wermuth/Marc/Spearman_TS_norm.RData")


## T4 Process
rhos <- c(-0.15, -0.08, 0, 0.08, 0.15)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 4))
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 4))
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 4))
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 4))
        pearson <- cor(X, Y)
        sigma <- sqrt(Rho_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 4))
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 4))
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        sigma <- 3/2 * sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

save(decision_kendall_array, file = "/home/fuchs/agmisc/wermuth/Marc/Kendall_TS_t4.RData")
save(decision_pearson_array, file = "/home/fuchs/agmisc/wermuth/Marc/Pearson_TS_t4.RData")
save(decision_spearman_array, file = "/home/fuchs/agmisc/wermuth/Marc/Spearman_TS_t4.RData")


## Cauchy Process
rhos <- c(-0.06, -0.03, 0, 0.03, 0.06)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 1))
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 1))
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 1))
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 1))
        pearson <- cor(X, Y)
        sigma <- sqrt(Rho_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        X <- arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 1))
        Y <- rho * X + sqrt(1 - rho^2) * arima.sim(model = list(ar = 0.8), n = Ti, rand.gen = function(n) rt(n, df = 1))
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        sigma <- 3/2 * sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

save(decision_kendall_array, file = "/home/fuchs/agmisc/wermuth/Marc/Kendall_TS_cauchy.RData")
save(decision_pearson_array, file = "/home/fuchs/agmisc/wermuth/Marc/Pearson_TS_cauchy.RData")
save(decision_spearman_array, file = "/home/fuchs/agmisc/wermuth/Marc/Spearman_TS_cauchy.RData")

## TEAR Process
r <- 0.8
rhos <- c(0, 0.07, 0.14)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        Xt <- rexp(1)
        eps <- rexp(Ti)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- rbinom(1, 1, r) * Xt + (1 - r) * eps[t]
          X[t] <- Xt
        }
        Ut <- rexp(1)
        nu <- rexp(Ti)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- rbinom(1, 1, r) * Ut + (1 - r) * nu[t]
          U[t] <- Ut
        }
        B_rho <- rbinom(Ti, 1, rho)
        Y <- B_rho * X + (1 - B_rho) * U
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        Xt <- rexp(1)
        eps <- rexp(Ti)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- rbinom(1, 1, r) * Xt + (1 - r) * eps[t]
          X[t] <- Xt
        }
        Ut <- rexp(1)
        nu <- rexp(Ti)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- rbinom(1, 1, r) * Ut + (1 - r) * nu[t]
          U[t] <- Ut
        }
        B_rho <- rbinom(Ti, 1, rho)
        Y <- B_rho * X + (1 - B_rho) * U
        pearson <- cor(X, Y)
        sigma <- sqrt(Rho_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i) 
        Xt <- rexp(1)
        eps <- rexp(Ti)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- rbinom(1, 1, r) * Xt + (1 - r) * eps[t]
          X[t] <- Xt
        }
        Ut <- rexp(1)
        nu <- rexp(Ti)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- rbinom(1, 1, r) * Ut + (1 - r) * nu[t]
          U[t] <- Ut
        }
        B_rho <- rbinom(Ti, 1, rho)
        Y <- B_rho * X + (1 - B_rho) * U
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        sigma <- 3/2 * sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

save(decision_kendall_array, file = "/home/fuchs/agmisc/wermuth/Marc/Kendall_TEAR.RData")
save(decision_pearson_array, file = "/home/fuchs/agmisc/wermuth/Marc/Pearson_TEAR.RData")
save(decision_spearman_array, file = "/home/fuchs/agmisc/wermuth/Marc/Spearman_TEAR.RData")


## Discrete Process: Pois
mu <- 1 # Specify 0.5 in order to get the DGP with the higher tie probability
# rhos <- round(head(seq(0, 1, 0.01), -1), digits = 2) # negative dependence is difficult for count data
rhos <- c(0, 0.04, 0.085)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_tau_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_gamma_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)

for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in SampleSizes){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        Xt <- rpois(1, mu)
        eps <- rpois(Ti, mu*(1-0.8))
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- rbinom(1, Xt, 0.8) + eps[t]
          X[t] <- Xt
        }
        Ut <- rpois(1, mu)
        nu <- rpois(Ti, mu*(1-0.8))
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- rbinom(1, Ut, 0.8) + nu[t]
          U[t] <- Ut
        }
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
        }
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      # decision_tau_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   Xt <- rpois(1, mu)
      #   eps <- rpois(Ti, mu*(1-0.8))
      #   X <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Xt <- rbinom(1, Xt, 0.8) + eps[t]
      #     X[t] <- Xt
      #   }
      #   Ut <- rpois(1, mu)
      #   nu <- rpois(Ti, mu*(1-0.8))
      #   U <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Ut <- rbinom(1, Ut, 0.8) + nu[t]
      #     U[t] <- Ut
      #   }
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
      #   }
      #   X_TieProb <- sum((table(X)/length(X))^2)
      #   Y_TieProb <- sum((table(Y)/length(Y))^2)
      #   tau_b <- cor(X, Y, method = "kendall")
      #   sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling") / (1 - X_TieProb) / (1 - Y_TieProb))
      #   as.numeric(isFALSE(data.table::between(tau_b, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      # }
      # decision_gamma <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   Xt <- rpois(1, mu)
      #   eps <- rpois(Ti, mu*(1-0.8))
      #   X <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Xt <- rbinom(1, Xt, 0.8) + eps[t]
      #     X[t] <- Xt
      #   }
      #   Ut <- rpois(1, mu)
      #   nu <- rpois(Ti, mu*(1-0.8))
      #   U <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Ut <- rbinom(1, Ut, 0.8) + nu[t]
      #     U[t] <- Ut
      #   }
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
      #   }
      #   X_TieProb <- sum((table(X)/length(X))^2)
      #   Y_TieProb <- sum((table(Y)/length(Y))^2)
      #   X_TieProb3 <- sum((table(X)/length(X))^3)
      #   Y_TieProb3 <- sum((table(Y)/length(Y))^3)
      #   kendall_info <- DescTools:::.DoCount(X, Y)
      #   gamma <- (kendall_info$C - kendall_info$D) / (kendall_info$C + kendall_info$D)
      #   sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling") / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)
      #   as.numeric(isFALSE(data.table::between(gamma, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      # }
      # decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   Xt <- rpois(1, mu)
      #   eps <- rpois(Ti, mu*(1-0.8))
      #   X <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Xt <- rbinom(1, Xt, 0.8) + eps[t]
      #     X[t] <- Xt
      #   }
      #   Ut <- rpois(1, mu)
      #   nu <- rpois(Ti, mu*(1-0.8))
      #   U <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Ut <- rbinom(1, Ut, 0.8) + nu[t]
      #     U[t] <- Ut
      #   }
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
      #   }
      #   pearson <- cor(X, Y)
      #   sigma <- sqrt(Rho_ind_LRV(X, Y, bandwidth = "Dehling"))
      #   as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      # }
      # decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   Xt <- rpois(1, mu)
      #   eps <- rpois(Ti, mu*(1-0.8))
      #   X <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Xt <- rbinom(1, Xt, 0.8) + eps[t]
      #     X[t] <- Xt
      #   }
      #   Ut <- rpois(1, mu)
      #   nu <- rpois(Ti, mu*(1-0.8))
      #   U <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Ut <- rbinom(1, Ut, 0.8) + nu[t]
      #     U[t] <- Ut
      #   }
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
      #   }
      #   spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
      #   sigma <- sqrt(9 / 4 * Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
      #   as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      # }
      decision_kendall_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_kendall
      # decision_tau_b_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_tau_b
      # decision_gamma_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_gamma
      # decision_pearson_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_pearson
      # decision_spearman_array[as.character(alpha), as.character(Ti),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)

vec <- cbind(SampleSizes, rep(NA, length(SampleSizes)))
k <- 0
for (Ti in SampleSizes){
  k <- k + 1
  vec[k, 2] <- mean(decision_kendall_array["0.1", paste(Ti),,])
}
plot(vec, ylim=c(0.1, 0.18))

save(decision_kendall_array, file = "/home/fuchs/agmisc/wermuth/Marc/Kendall_TS_Pois1.RData")
save(decision_tau_b_array, file = "/home/fuchs/agmisc/wermuth/Marc/Tau_b_TS_Pois1.RData")
save(decision_gamma_array, file = "/home/fuchs/agmisc/wermuth/Marc/Gamma_TS_Pois1.RData")
save(decision_pearson_array, file = "/home/fuchs/agmisc/wermuth/Marc/Pearson_TS_Pois1.RData")
save(decision_spearman_array, file = "/home/fuchs/agmisc/wermuth/Marc/Spearman_TS_Pois1.RData")


## Discrete Process: Zipf
# rhos <- round(head(seq(0, 1, 0.01), -1), digits = 2) # negative dependence is difficult for count data
rhos <- c(0, 0.047, 0.098)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_tau_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_gamma_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing: Something does not work. If MC > 11, nothing happens anymore. So need to split the simulation into smaller pieces of MC = 11.
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
Start_time <- Sys.time()
for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in (SampleSizes + 1000)){
      print("A")
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        Xt <- 1
        eps <- VGAM::rzeta(Ti, shape = 1.5)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- rbinom(1, Xt, 0.8) + eps[t]
          X[t] <- Xt
        }
        Ut <- 1
        nu <- VGAM::rzeta(Ti, shape = 1.5)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- rbinom(1, Ut, 0.8) + nu[t]
          U[t] <- Ut
        }
        X <- X[1001:Ti]
        U <- U[1001:Ti]
        Ti <- length(X)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
        }
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      # decision_tau_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   Xt <- 1
      #   eps <- VGAM::rzeta(Ti, shape = 1.5)
      #   X <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Xt <- rbinom(1, Xt, 0.8) + eps[t]
      #     X[t] <- Xt
      #   }
      #   Ut <- 1
      #   nu <- VGAM::rzeta(Ti, shape = 1.5)
      #   U <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Ut <- rbinom(1, Ut, 0.8) + nu[t]
      #     U[t] <- Ut
      #   }
      #   X <- X[1001:Ti]
      #   U <- U[1001:Ti]
      #   Ti <- length(X)
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
      #   }
      #   X_TieProb <- sum((table(X)/length(X))^2)
      #   Y_TieProb <- sum((table(Y)/length(Y))^2)
      #   tau_b <- cor(X, Y, method = "kendall")
      #   sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling") / (1 - X_TieProb) / (1 - Y_TieProb))
      #   as.numeric(isFALSE(data.table::between(tau_b, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      # }
      # decision_gamma <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   Xt <- 1
      #   eps <- VGAM::rzeta(Ti, shape = 1.5)
      #   X <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Xt <- rbinom(1, Xt, 0.8) + eps[t]
      #     X[t] <- Xt
      #   }
      #   Ut <- 1
      #   nu <- VGAM::rzeta(Ti, shape = 1.5)
      #   U <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Ut <- rbinom(1, Ut, 0.8) + nu[t]
      #     U[t] <- Ut
      #   }
      #   X <- X[1001:Ti]
      #   U <- U[1001:Ti]
      #   Ti <- length(X)
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
      #   }
      #   X_TieProb <- sum((table(X)/length(X))^2)
      #   Y_TieProb <- sum((table(Y)/length(Y))^2)
      #   kendall_info <- DescTools:::.DoCount(X, Y)
      #   gamma <- (kendall_info$C - kendall_info$D) / (kendall_info$C + kendall_info$D)
      #   sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling") / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)
      #   as.numeric(isFALSE(data.table::between(gamma, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      # }
      # decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   Xt <- 1
      #   eps <- VGAM::rzeta(Ti, shape = 1.5)
      #   X <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Xt <- rbinom(1, Xt, 0.8) + eps[t]
      #     X[t] <- Xt
      #   }
      #   Ut <- 1
      #   nu <- VGAM::rzeta(Ti, shape = 1.5)
      #   U <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Ut <- rbinom(1, Ut, 0.8) + nu[t]
      #     U[t] <- Ut
      #   }
      #   X <- X[1001:Ti]
      #   U <- U[1001:Ti]
      #   Ti <- length(X)
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
      #   }
      #   pearson <- cor(X, Y)
      #   sigma <- sqrt(Rho_ind_LRV(X, Y, bandwidth = "Dehling"))
      #   as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      # }
      # decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
      #   set.seed(i)
      #   Xt <- 1
      #   eps <- VGAM::rzeta(Ti, shape = 1.5)
      #   X <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Xt <- rbinom(1, Xt, 0.8) + eps[t]
      #     X[t] <- Xt
      #   }
      #   Ut <- 1
      #   nu <- VGAM::rzeta(Ti, shape = 1.5)
      #   U <- rep(NA, Ti)
      #   for(t in 1:Ti){
      #     Ut <- rbinom(1, Ut, 0.8) + nu[t]
      #     U[t] <- Ut
      #   }
      #   X <- X[1001:Ti]
      #   U <- U[1001:Ti]
      #   Ti <- length(X)
      #   Y <- rep(NA, Ti)
      #   for (t in 1:Ti) {
      #     Y[t] <- rbinom(1, X[t], rho) + rbinom(1, U[t], 1 - rho)
      #   }
      #   spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
      #   sigma <- sqrt(9 / 4 * Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
      #   as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      # }
      decision_kendall_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_kendall
      # decision_tau_b_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_tau_b
      # decision_gamma_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_gamma
      # decision_pearson_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_pearson
      # decision_spearman_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_spearman
    }
  }
} # 1 denotes a rejection of the null hypothesis
stopCluster(cl)
End_time <- Sys.time()
End_time - Start_time

vec <- cbind(SampleSizes, rep(NA, length(SampleSizes)))
k <- 0
for (Ti in SampleSizes){
  k <- k + 1
  vec[k, 2] <- mean(decision_kendall_array["0.1", paste(Ti),,])
}
plot(vec, ylim=c(0.1, 0.18))

save(decision_kendall_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Zipf/Kendall_TS_Zipf_91.RData")
save(decision_tau_b_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Zipf/Tau_b_TS_Zipf_91.RData")
save(decision_gamma_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Zipf/Gamma_TS_Zipf_91.RData")
save(decision_pearson_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Zipf/Pearson_TS_Zipf_91.RData")
save(decision_spearman_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Zipf/Spearman_TS_Zipf_91.RData")
save(decision_rho_b_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Zipf/Rho_b_TS_Zipf_91.RData")

## Discrete Process: Skellam:
# rhos <- round(head(seq(0, 1, 0.01), -1), digits = 2) # negative dependence is difficult for count data
rhos <- c(-0.09, -0.045, 0, 0.045, 0.09)

decision_kendall_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_tau_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_gamma_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_pearson_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_spearman_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array
decision_rho_b_array <- array(data = NA, dim = c(length(alphas), length(SampleSizes), MC, length(rhos)), dimnames = list(alphas, SampleSizes, 1:MC, rhos)) # Initialize results array

# Start cluster for parallel computing
cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
Start_time <- Sys.time()
for (rho in rhos){
  for (alpha in alphas) {
    for (Ti in (SampleSizes + 1000)){
      decision_kendall <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        Xt <- 1
        eps <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- sign(Xt) * rbinom(1, abs(Xt), 0.8) + eps[t]
          X[t] <- Xt
        }
        Ut <- 1
        nu <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- sign(Ut) * rbinom(1, abs(Ut), 0.8) + nu[t]
          U[t] <- Ut
        }
        X <- X[1001:Ti]
        U <- U[1001:Ti]
        Ti <- length(X)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(U[t]) * rbinom(1, abs(U[t]), abs(1 - abs(rho)))
        }
        kendall_info <- DescTools:::.DoCount(X, Y)
        kendall <- (kendall_info$C - kendall_info$D) / choose(Ti, 2)
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(kendall, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_tau_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        Xt <- 1
        eps <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- sign(Xt) * rbinom(1, abs(Xt), 0.8) + eps[t]
          X[t] <- Xt
        }
        Ut <- 1
        nu <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- sign(Ut) * rbinom(1, abs(Ut), 0.8) + nu[t]
          U[t] <- Ut
        }
        X <- X[1001:Ti]
        U <- U[1001:Ti]
        Ti <- length(X)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(U[t]) * rbinom(1, abs(U[t]), abs(1 - abs(rho)))
        }
        X_TieProb <- sum((table(X)/length(X))^2)
        Y_TieProb <- sum((table(Y)/length(Y))^2)
        tau_b <- cor(X, Y, method = "kendall")
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling") / (1 - X_TieProb) / (1 - Y_TieProb))
        as.numeric(isFALSE(data.table::between(tau_b, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_gamma <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        Xt <- 1
        eps <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- sign(Xt) * rbinom(1, abs(Xt), 0.8) + eps[t]
          X[t] <- Xt
        }
        Ut <- 1
        nu <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- sign(Ut) * rbinom(1, abs(Ut), 0.8) + nu[t]
          U[t] <- Ut
        }
        X <- X[1001:Ti]
        U <- U[1001:Ti]
        Ti <- length(X)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(U[t]) * rbinom(1, abs(U[t]), abs(1 - abs(rho)))
        }
        X_TieProb <- sum((table(X)/length(X))^2)
        Y_TieProb <- sum((table(Y)/length(Y))^2)
        kendall_info <- DescTools:::.DoCount(X, Y)
        gamma <- (kendall_info$C - kendall_info$D) / (kendall_info$C + kendall_info$D)
        sigma <- sqrt(Tau_ind_LRV(X, Y, bandwidth = "Dehling") / (1 - X_TieProb)^2 / (1 - Y_TieProb)^2)
        as.numeric(isFALSE(data.table::between(gamma, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_pearson <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        Xt <- 1
        eps <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- sign(Xt) * rbinom(1, abs(Xt), 0.8) + eps[t]
          X[t] <- Xt
        }
        Ut <- 1
        nu <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- sign(Ut) * rbinom(1, abs(Ut), 0.8) + nu[t]
          U[t] <- Ut
        }
        X <- X[1001:Ti]
        U <- U[1001:Ti]
        Ti <- length(X)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(U[t]) * rbinom(1, abs(U[t]), abs(1 - abs(rho)))
        }
        pearson <- cor(X, Y)
        sigma <- sqrt(Rho_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(pearson, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_spearman <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        Xt <- 1
        eps <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- sign(Xt) * rbinom(1, abs(Xt), 0.8) + eps[t]
          X[t] <- Xt
        }
        Ut <- 1
        nu <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- sign(Ut) * rbinom(1, abs(Ut), 0.8) + nu[t]
          U[t] <- Ut
        }
        X <- X[1001:Ti]
        U <- U[1001:Ti]
        Ti <- length(X)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(U[t]) * rbinom(1, abs(U[t]), abs(1 - abs(rho)))
        }
        spearman <- 12 * (Ti - 1) / Ti^3 * cov(X, Y, method = "spearman")
        sigma <- sqrt(9 / 4 * Tau_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(spearman, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_rho_b <- foreach(i = 1:MC, .combine = 'rbind') %dopar% {
        set.seed(i)
        Xt <- 1
        eps <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        X <- rep(NA, Ti)
        for(t in 1:Ti){
          Xt <- sign(Xt) * rbinom(1, abs(Xt), 0.8) + eps[t]
          X[t] <- Xt
        }
        Ut <- 1
        nu <- rpois(Ti, 0.2) - rpois(Ti, 0.2)
        U <- rep(NA, Ti)
        for(t in 1:Ti){
          Ut <- sign(Ut) * rbinom(1, abs(Ut), 0.8) + nu[t]
          U[t] <- Ut
        }
        X <- X[1001:Ti]
        U <- U[1001:Ti]
        Ti <- length(X)
        Y <- rep(NA, Ti)
        for (t in 1:Ti) {
          Y[t] <- sign(rho) * sign(X[t]) * rbinom(1, abs(X[t]), abs(rho)) + ifelse(rho >= 0, 1, -1) * sign(1 - abs(rho)) * sign(U[t]) * rbinom(1, abs(U[t]), abs(1 - abs(rho)))
        }
        rho_b <- cor(X, Y, method = "spearman")
        sigma <- sqrt(Rhob_ind_LRV(X, Y, bandwidth = "Dehling"))
        as.numeric(isFALSE(data.table::between(rho_b, qnorm(alpha/2)*sigma/sqrt(Ti), qnorm(1 - alpha/2)*sigma/sqrt(Ti))))
      }
      decision_kendall_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_kendall
      decision_tau_b_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_tau_b
      decision_gamma_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_gamma
      decision_pearson_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_pearson
      decision_spearman_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_spearman
      decision_rho_b_array[as.character(alpha), as.character(Ti - 1000),,as.character(rho)] <- decision_rho_b
    }
  }
} # 1 denotes a rejection of the null hypothesis

stopCluster(cl)
End_time <- Sys.time()
End_time - Start_time

save(decision_kendall_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Skellam/Kendall_TS_Skellam.RData")
save(decision_tau_b_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Skellam/Tau_b_TS_Skellam.RData")
save(decision_gamma_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Skellam/Gamma_TS_Skellam.RData")
save(decision_pearson_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Skellam/Pearson_TS_Skellam.RData")
save(decision_spearman_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Skellam/Spearman_TS_Skellam.RData")
save(decision_rho_b_array, file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Projects/RankAutocorrelations/Results/Simulations/2Series_Testing/TS_Skellam/Rho_b_TS_Skellam.RData")

